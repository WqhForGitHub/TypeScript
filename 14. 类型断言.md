# 1. 简介

对于没有类型声明的值，TypeScript 会进行类型推断，很多时候得到的结果，未必是开发者想要的。

```typescript
type T = "a" | "b" | "c";
let foo = "a";

let bar: T = foo; // 报错
```

上面示例中，最后一行报错，原因是 TypeScript 推断变量 foo 的类型是 string，而变量 bar 的类型是 "a" | "b" | "c"，前者是后者的父类型。父类型不能赋值给子类型，所以就报错了。

TypeScript 提供了类型断言这样一种手段，允许开发者在代码中断言某个值的类型，告诉编译器此处的值是什么类型。TypeScript 一旦发现存在类型断言，就不再对该值进行类型推断，而是直接采用断言给出的类型。

这种做法的实质是，允许开发者在某个位置绕过编辑器的类型推断，让本来通不过类型检查的代码能够通过，避免编译器报错。这样虽然削弱了 TypeScript 类型系统的严格性，但是为开发者带来了方便，毕竟开发者比编译器更了解自己的代码。

回到上面的例子，解决方法就是进行类型断言，在赋值时断言变量 foo 的类型。

```typescript
type T = "a" | "b" | "c";

let foo = "a";
let bar: T = foo as T; // 正确
```

上面示例中，最后一行的 foo as T 表示告诉编译器，变量 foo 的类型断言为 T，所以这一行不再需要类型推断了，编译器直接把 foo 的类型当作 T，就不会报错了。

总之，类型断言并不是真的改变一个值的类型，而是提示编译器，应该如何处理这个值。

类型断言有两种语法。

```typescript
// 语法一：<类型>值
<Type>value

// 语法二：值 as 类型
value as Type
```

上面两种语法是等价的，value 表示值，Type 表示类型。早期只有语法一，后来因为 TypeScript 开始支持 React 的 JSX 语法（尖括号表示 HTML 元素），为了避免两者冲突，就引入了语法二。目前，推荐使用语法二。

```typescript
// 语法一
let bar: T = <T>foo;

// 语法二
let bar: T = foo as T;
```

上面示例是两种类型断言的语法，其中的语法一因为跟 JSX 语法冲突，使用时必须关闭 TypeScript 的 React 支持，否则会无法识别。由于这个原因，现在一般都使用语法二。

下面看一个例子。《对象》一章提到过，对象类型有严格字面量检查，如果存在额外的属性会报错。

```typescript
// 报错
const p: { x: number } = { x: 0, y: 0 };
```

上面示例中，等号右侧是一个对象字面量，多出了属性 y，导致报错。解决方法就是使用类型断言，可以用两种不同的断言。

```typescript
// 正确
const p0: { x: number } = { x: 0, y: 0 } as { x: number };

// 正确
const p1: { x: number } = { x: 0, y: 0 } as { x: number, y: number }
```

上面示例中，两种类型断言都是正确的。第一种断言将类型改成与等号左边一致，第二种断言使得等号右边的类型是左边类型的子类型，子类型可以赋值给父类型，同时因为存在类型断言，就没有严格字面量检查了，所以不报错。

下面是一个网页编程的实际例子。

```typescript
const username = document.getElementById("username");

if (username) {
    (username as HTMLInputElement).value; // 正确
}
```

上面示例中，变量 username 的类型是 HTMLElement | null，排除了 null 的情况以后，HTMLElement 类型是没有 value 属性的。如果 username 是一个输入框，那么就可以通过类型断言，将它的类型改成 HTMLInputElement，就可以读取 value 属性。

注意，上例的类型断言的圆括号是必需的，否则 username 会被断言成 HTMLInputElement.value，从而报错。

类型断言不应滥用，因为它改变了 TypeScript 的类型检查，很可能埋下错误的隐患。

```typescript
const data: object = {
    a: 1,
    b: 2,
    c: 3
};

data.length; // 报错
(data as Array<string>).length; // 正确
```

上面示例中，变量 data 是一个对象，没有 length 属性。但是通过类型断言，可以将它的类型断言为数组，这样使用 length 属性就能通过类型检查。但是，编译后的代码在运行时依然会报错，所以类型断言可以让错误的代码通过编译。

类型断言的一大用处是，指定 unknown 类型的变量的具体类型。

```typescript
const value: unknown = "Hello, World";

const s1: string = value; // 报错
const s2: string = value as string; // 正确
```

上面示例中，unknown 类型的变量 value 不能直接赋值给其他类型的变量，但是可以将它断言为其他类型，这样就可以赋值给别的变量了。

<br>

# 2. 类型断言的条件

类型断言并不意味着，可以把某个值断言为任意类型。

```typescript
const n = 1;
const m: string = n as string; // 报错
```

上面示例中，变量 n 是数值，无法把它断言成字符串，TypeScript 会报错。

类型断言的使用前提是，值的实际类型与断言的类型必需满足一个条件。

```typescript
expr as T
```

上面代码中，expr 是实际的值，T 是类型断言，它们必需满足下面的条件：expr 是 T 的子类型，或者 T 是 expr 的子类型。

也就是说，类型断言要求实际的类型与断言的类型兼容，实际类型可以断言为一个更加宽泛的类型（父类型），也可以断言为一个更加精确的类型（子类型），但不能断言为一个完全无关的类型。
